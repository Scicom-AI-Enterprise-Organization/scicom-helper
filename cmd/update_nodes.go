package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"
)

const (
	markerStart = "# BEGIN SCICOM-HELPER TELEPORT CONFIG"
	markerEnd   = "# END SCICOM-HELPER TELEPORT CONFIG"
)

// updateNodes fetches Teleport nodes and updates SSH config
func updateNodes() error {
	fmt.Println("\n=== Update Teleport Nodes ===")
	fmt.Println()

	// Check if logged in
	if !isTeleportLoggedIn() {
		fmt.Println("You are not logged in to Teleport")
		fmt.Println("Please run 'Teleport Setup' first")
		return fmt.Errorf("not logged in to Teleport")
	}

	// Get SSH config path
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %v", err)
	}

	sshDir := filepath.Join(home, ".ssh")
	sshConfig := filepath.Join(sshDir, "config")

	// Ensure .ssh directory exists
	if err := os.MkdirAll(sshDir, 0700); err != nil {
		return fmt.Errorf("failed to create .ssh directory: %v", err)
	}

	// Backup existing config
	if _, err := os.Stat(sshConfig); err == nil {
		backupPath := fmt.Sprintf("%s.backup.%s", sshConfig, time.Now().Format("20060102_150405"))
		fmt.Printf("Backing up existing SSH config to: %s\n", backupPath)

		data, err := os.ReadFile(sshConfig)
		if err != nil {
			return fmt.Errorf("failed to read SSH config: %v", err)
		}

		if err := os.WriteFile(backupPath, data, 0600); err != nil {
			return fmt.Errorf("failed to create backup: %v", err)
		}
	}

	// Get Teleport configuration
	fmt.Println("Generating Teleport SSH configuration...")
	tshConfig, err := runCommand("tsh", "config")
	if err != nil {
		return fmt.Errorf("failed to get tsh config: %v", err)
	}

	// Get user info for certificate paths
	user, err := getTeleportUser()
	if err != nil {
		// If we can't get the user from tsh status, try to auto-detect from .tsh directory
		tshKeysDir := filepath.Join(home, ".tsh", "keys", teleportProxy)
		entries, readErr := os.ReadDir(tshKeysDir)
		if readErr == nil && len(entries) > 0 {
			// Find first file that doesn't end with -ssh or other suffixes
			for _, entry := range entries {
				name := entry.Name()
				if !entry.IsDir() && !strings.HasSuffix(name, "-ssh") &&
					!strings.HasSuffix(name, ".pub") && !strings.HasSuffix(name, ".cert") {
					user = strings.TrimSuffix(name, filepath.Ext(name))
					fmt.Printf("Auto-detected Teleport user: %s\n", user)
					break
				}
			}
		}

		// If still no user, return the original error
		if user == "" {
			return fmt.Errorf("failed to get Teleport user: %v\n\nPlease run: tsh status\nAnd share the output", err)
		}
	}

	// Get list of nodes
	fmt.Println("Fetching node list from Teleport...")
	nodes, err := getTeleportNodes()
	if err != nil {
		return fmt.Errorf("failed to get nodes: %v", err)
	}

	if len(nodes) == 0 {
		fmt.Println("Warning: No nodes found")
		return nil
	}

	// Get available logins and pick the best default
	defaultUser := "ubuntu" // fallback
	allLogins, err := getAllLogins()
	if err == nil && len(allLogins) > 0 {
		// Prioritize: ubuntu > root > others
		defaultUser = pickDefaultLogin(allLogins)
		fmt.Printf("Using default login: %s\n", defaultUser)
	}

	// Read existing config
	var existingConfig string
	data, err := os.ReadFile(sshConfig)
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to read SSH config: %v", err)
	}
	existingConfig = string(data)

	// Remove old scicom-helper section if it exists
	if strings.Contains(existingConfig, markerStart) {
		fmt.Println("Removing existing scicom-helper configuration...")
		existingConfig = removeSection(existingConfig, markerStart, markerEnd)
	}

	// Build new configuration section
	var configBuilder strings.Builder
	configBuilder.WriteString(markerStart)
	configBuilder.WriteString("\n")
	configBuilder.WriteString(fmt.Sprintf("# Auto-generated by scicom-helper\n"))
	configBuilder.WriteString(fmt.Sprintf("# Last updated: %s\n", time.Now().Format("2006-01-02 15:04:05")))
	configBuilder.WriteString(fmt.Sprintf("# Run 'scicom-helper' -> 'Teleport Update Nodes' to refresh\n"))
	configBuilder.WriteString("\n")

	// Add base Teleport configuration
	configBuilder.WriteString(tshConfig)
	configBuilder.WriteString("\n")

	// Add wildcard patterns for Teleport-managed hosts
	tshKeysDir := filepath.Join(home, ".tsh", "keys", teleportProxy)
	configBuilder.WriteString("# Wildcard patterns for Teleport-managed hosts\n")

	// Build host list: all nodes + wildcard domains
	hostList := make([]string, len(nodes))
	copy(hostList, nodes)
	hostList = append(hostList, fmt.Sprintf("*.%s", teleportProxy))
	hostList = append(hostList, teleportProxy)

	configBuilder.WriteString(fmt.Sprintf("Host %s\n", strings.Join(hostList, " ")))
	configBuilder.WriteString(fmt.Sprintf("    UserKnownHostsFile \"%s/.tsh/known_hosts\"\n", home))
	configBuilder.WriteString(fmt.Sprintf("    IdentityFile \"%s/%s\"\n", tshKeysDir, user))
	configBuilder.WriteString(fmt.Sprintf("    CertificateFile \"%s/%s-ssh/%s-cert.pub\"\n", tshKeysDir, user, teleportProxy))
	configBuilder.WriteString("\n")

	// For non-proxy hosts (all nodes and wildcard subdomains)
	proxyHostList := make([]string, len(nodes))
	copy(proxyHostList, nodes)
	proxyHostList = append(proxyHostList, fmt.Sprintf("*.%s", teleportProxy))

	configBuilder.WriteString(fmt.Sprintf("Host %s\n", strings.Join(proxyHostList, " ")))
	configBuilder.WriteString("    Port 3022\n")
	configBuilder.WriteString(fmt.Sprintf("    ProxyCommand \"tsh\" proxy ssh --cluster=%s --proxy=%s:443 %%r@%%h:%%p\n", teleportProxy, teleportProxy))
	configBuilder.WriteString("\n")

	// Add specific node entries
	configBuilder.WriteString("# Specific node aliases\n")
	for _, node := range nodes {
		configBuilder.WriteString(fmt.Sprintf("Host %s\n", node))
		configBuilder.WriteString(fmt.Sprintf("    HostName %s.%s\n", node, teleportProxy))
		configBuilder.WriteString(fmt.Sprintf("    User %s\n", defaultUser))
		configBuilder.WriteString("\n")
	}

	configBuilder.WriteString(markerEnd)
	configBuilder.WriteString("\n")

	// Write updated config
	newConfig := existingConfig + "\n" + configBuilder.String()
	if err := os.WriteFile(sshConfig, []byte(newConfig), 0600); err != nil {
		return fmt.Errorf("failed to write SSH config: %v", err)
	}

	fmt.Println()
	fmt.Println("=== Update Complete! ===")
	fmt.Println()
	fmt.Printf("Added %d node(s) to SSH config:\n", len(nodes))
	for _, node := range nodes {
		fmt.Printf("  - %s\n", node)
	}
	fmt.Println()
	fmt.Println("You can now:")
	fmt.Println("  1. Connect via SSH: ssh <node-name>")
	fmt.Println("  2. Use VS Code Remote-SSH extension to connect")
	fmt.Println("  3. See these hosts in VS Code's Remote Explorer")
	fmt.Println()

	return nil
}

// removeSection removes a section between start and end markers from content
func removeSection(content, start, end string) string {
	startIdx := strings.Index(content, start)
	if startIdx == -1 {
		return content
	}

	endIdx := strings.Index(content[startIdx:], end)
	if endIdx == -1 {
		return content
	}

	// Include the end marker in removal
	endIdx = startIdx + endIdx + len(end)

	// Remove the section and any trailing newlines
	result := content[:startIdx] + content[endIdx:]
	result = strings.TrimRight(result, "\n")

	return result
}
